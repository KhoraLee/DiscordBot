package me.khora.eris

import me.khora.eris.command.ISlashCommand
import me.khora.eris.command.SlashCommandManager
import me.khora.eris.command.audio.QueueCommand
import net.dv8tion.jda.api.EmbedBuilder
import net.dv8tion.jda.api.entities.Message
import net.dv8tion.jda.api.events.interaction.ButtonClickEvent
import net.dv8tion.jda.api.events.interaction.SlashCommandEvent
import net.dv8tion.jda.api.hooks.ListenerAdapter
import org.slf4j.LoggerFactory
import java.awt.Color

class SlashCommandListener(private val cmdManager: SlashCommandManager): ListenerAdapter() {
    val logger = LoggerFactory.getLogger(QueueCommand::class.java)

    override fun onSlashCommand(event: SlashCommandEvent) {
        logger.debug("Slash Command received - ${event.name}")
        if (event.guild == null) return
        val cmd = cmdManager.getCommand(event.name)
        if (cmd != null) {
            invokeHandle(cmd, event)
        } else {
            event.reply("I can't handle that command right now :(").setEphemeral(true).queue()
        }
    }

    override fun onButtonClick(event: ButtonClickEvent) {
        // users can spoof this id so be careful what you do with this
        val id = event.componentId.split(":").toTypedArray() // this is the custom id we specified in our button
        val authorId = id[0]
        val type = id[1]
        // When storing state like this is it is highly recommended to do some kind of verification that it was generated by you, for instance a signature or local cache
        if (authorId != event.user.id) return
        event.deferEdit().queue() // acknowledge the button was clicked, otherwise the interaction will fail
        val channel = event.channel
        when (type) {
            "prune" -> {
                val amount = id[2].toInt()
                event.channel.iterableHistory
                    .skipTo(event.messageIdLong)
                    .takeAsync(amount)
                    .thenAccept { messages: List<Message?>? ->
                        channel.purgeMessages(
                            messages!!
                        )
                    }
                event.hook.deleteOriginal().queue()
            }
            "delete" -> event.hook.deleteOriginal().queue()
        }
    }

    fun invokeHandle(cmd: ISlashCommand, event: SlashCommandEvent) {
        try {
            cmd.handle(event)
        } catch(e: Exception) {
            val builder = EmbedBuilder()
                .setTitle("An error occurred while executing Play command!")
                .addField(
                    "Guild",
                    if (event.guild == null) "None (Direct message)" else event.guild!!.idLong.toString() + " (" + event.guild!!
                        .name + ")",
                    true
                )
                .addField(
                    "User",
                    event.member!!.user.asMention + " (" + event.member!!.user.asTag + ")",
                    true
                )
                .setDescription(
                    "```${e.localizedMessage}```".trimIndent()
                )
                .setColor(Color.RED)
            event.jda.openPrivateChannelById(338866874114637826)
                .flatMap { c -> c.sendMessageEmbeds(builder.build()) }
                .queue()

            event
                .reply("An unknown error occurred! `" + e.localizedMessage.toString() + "` The owner of the bot has been notified of this!")
                .queue({ s -> }) { ex -> }
            e.printStackTrace()
        }
    }

}